<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>blogpost - Summary</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">blogpost</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./index.html" rel="" target="" aria-current="page">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#week-2" id="toc-week-2" class="nav-link active" data-scroll-target="#week-2">Week 2</a>
  <ul class="collapse">
  <li><a href="#se1" id="toc-se1" class="nav-link" data-scroll-target="#se1">SE1</a></li>
  <li><a href="#fb1" id="toc-fb1" class="nav-link" data-scroll-target="#fb1">FB1</a></li>
  </ul></li>
  <li><a href="#week-3" id="toc-week-3" class="nav-link" data-scroll-target="#week-3">Week 3</a>
  <ul class="collapse">
  <li><a href="#se2" id="toc-se2" class="nav-link" data-scroll-target="#se2">SE2</a></li>
  <li><a href="#fb2" id="toc-fb2" class="nav-link" data-scroll-target="#fb2">FB2</a></li>
  </ul></li>
  <li><a href="#week-4" id="toc-week-4" class="nav-link" data-scroll-target="#week-4">Week 4</a>
  <ul class="collapse">
  <li><a href="#se3" id="toc-se3" class="nav-link" data-scroll-target="#se3">SE3</a></li>
  <li><a href="#fb3" id="toc-fb3" class="nav-link" data-scroll-target="#fb3">FB3</a></li>
  </ul></li>
  <li><a href="#week-5" id="toc-week-5" class="nav-link" data-scroll-target="#week-5">Week 5</a>
  <ul class="collapse">
  <li><a href="#se4" id="toc-se4" class="nav-link" data-scroll-target="#se4">SE4</a></li>
  <li><a href="#fb4" id="toc-fb4" class="nav-link" data-scroll-target="#fb4">FB4</a></li>
  </ul></li>
  <li><a href="#week-7" id="toc-week-7" class="nav-link" data-scroll-target="#week-7">Week 7</a>
  <ul class="collapse">
  <li><a href="#se5" id="toc-se5" class="nav-link" data-scroll-target="#se5">SE5</a></li>
  <li><a href="#fb5" id="toc-fb5" class="nav-link" data-scroll-target="#fb5">FB5</a></li>
  </ul></li>
  <li><a href="#week-8" id="toc-week-8" class="nav-link" data-scroll-target="#week-8">Week 8</a>
  <ul class="collapse">
  <li><a href="#se6" id="toc-se6" class="nav-link" data-scroll-target="#se6">Se6</a></li>
  <li><a href="#fb6" id="toc-fb6" class="nav-link" data-scroll-target="#fb6">FB6</a></li>
  </ul></li>
  <li><a href="#week-9" id="toc-week-9" class="nav-link" data-scroll-target="#week-9">Week 9</a>
  <ul class="collapse">
  <li><a href="#se7" id="toc-se7" class="nav-link" data-scroll-target="#se7">Se7</a></li>
  <li><a href="#fb7" id="toc-fb7" class="nav-link" data-scroll-target="#fb7">FB7</a></li>
  </ul></li>
  <li><a href="#week-10" id="toc-week-10" class="nav-link" data-scroll-target="#week-10">Week 10</a>
  <ul class="collapse">
  <li><a href="#se8" id="toc-se8" class="nav-link" data-scroll-target="#se8">Se8</a></li>
  <li><a href="#fb8" id="toc-fb8" class="nav-link" data-scroll-target="#fb8">FB8</a></li>
  </ul></li>
  <li><a href="#week-11" id="toc-week-11" class="nav-link" data-scroll-target="#week-11">Week 11</a>
  <ul class="collapse">
  <li><a href="#se9" id="toc-se9" class="nav-link" data-scroll-target="#se9">Se9</a></li>
  <li><a href="#fb9" id="toc-fb9" class="nav-link" data-scroll-target="#fb9">FB9</a></li>
  </ul></li>
  <li><a href="#week-13" id="toc-week-13" class="nav-link" data-scroll-target="#week-13">Week 13</a>
  <ul class="collapse">
  <li><a href="#se10" id="toc-se10" class="nav-link" data-scroll-target="#se10">Se10</a></li>
  <li><a href="#db1" id="toc-db1" class="nav-link" data-scroll-target="#db1">DB1</a></li>
  </ul></li>
  <li><a href="#week-14" id="toc-week-14" class="nav-link" data-scroll-target="#week-14">Week 14</a>
  <ul class="collapse">
  <li><a href="#se11" id="toc-se11" class="nav-link" data-scroll-target="#se11">Se11</a></li>
  <li><a href="#db2" id="toc-db2" class="nav-link" data-scroll-target="#db2">DB2</a></li>
  </ul></li>
  <li><a href="#week-15" id="toc-week-15" class="nav-link" data-scroll-target="#week-15">Week 15</a>
  <ul class="collapse">
  <li><a href="#se12" id="toc-se12" class="nav-link" data-scroll-target="#se12">Se12</a></li>
  <li><a href="#db3" id="toc-db3" class="nav-link" data-scroll-target="#db3">DB3</a></li>
  </ul></li>
  <li><a href="#week-16" id="toc-week-16" class="nav-link" data-scroll-target="#week-16">Week 16</a>
  <ul class="collapse">
  <li><a href="#db4" id="toc-db4" class="nav-link" data-scroll-target="#db4">DB4</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Summary</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>By: Naboni Thomas</p>
<section id="week-2" class="level1">
<h1>Week 2</h1>
<section id="se1" class="level2">
<h2 class="anchored" data-anchor-id="se1">SE1</h2>
<p><strong>Summary</strong></p>
<p>The book discusses the differences between software engineering, programming, and computer science. Software engineering is more serious and involves applying theoretical knowledge to create something tangible. Software engineering practices are not as rigorous as other engineering fields, but the need for more rigorous methods is increasing. Software engineering includes writing code and using tools and processes to maintain it over time. The book emphasizes three principles for software organizations: Time and Change, Scale and Growth, and Trade-offs and Costs.</p>
<p><strong>Reflection</strong></p>
<p>After reading the book ‘Software Engineering’, I learned about the distinction between programming and software engineering. I didn’t know that they were related but they do different things for the same product. The field of software engineering involves rigorous methods such as running test cases for a program by writing code, which I believe most engineering fields don’t do.</p>
<p><strong>Use-case</strong> By using the skills from software engineering and considering the trade-offs and benefits, I would benefit in shaping up my skills and gain more understanding of it.</p>
</section>
<section id="fb1" class="level2">
<h2 class="anchored" data-anchor-id="fb1">FB1</h2>
<p><strong>Summary</strong></p>
<p>The book explains that software testing is a critical process in ensuring that software is reliable and free from errors. It helps to detect and fix bugs, improve the overall quality of the software, and make sure that it meets the user’s specified criteria and requirements. By testing, potential issues and vulnerabilities can be identified and addressed before they cause problems for end users.</p>
<p><strong>Reflection</strong></p>
<p>After reading this chapter, I learned that software testing is a critical process for ensuring the quality and reliability of software. It helps to identify and fix bugs, improve the overall user experience, and detect and fix issues before they impact end users.</p>
<p><strong>Use-case</strong></p>
<p>The information I learned from the chapter helps in many ways, such as running test suite cases. When using the Chasten package, we can go through the process of testing and making sure the software runs as expected.</p>
</section>
</section>
<section id="week-3" class="level1">
<h1>Week 3</h1>
<section id="se2" class="level2">
<h2 class="anchored" data-anchor-id="se2">SE2</h2>
<p><strong>Summary</strong></p>
<p>The book discusses the complectity and long-term nature of software engineering compared to programing. It discusses the challenges of managing changes, upgrades and dependencies in software projects, and the trase-offs associated with software sustainibility as it was mentioned in the SE1 reading assigned such as time, costs, growth of the software and among the other. The book also emphasizes the importance of team efforts in software enginerring tasks is much appriciated to individual efforts in programing tasks.</p>
<p><strong>Reflecttion</strong></p>
<p>This chapter underscores the significance of foresight, planning, and collaboration in the realm of software engineering. As a member of the development developers team, I find it beneficial to reflect on these aspects, particularly when faced with complex decisions. It’s crucial to approach problem-solving as a collective effort rather than as isolated individuals. This collaborative approach not only leverages the diverse skills and perspectives within the team but also fosters a sense of unity and shared responsibility.</p>
<p><strong>Use-case</strong></p>
<p>One use case could be, in our software enginerring class, every individual is assigned with a different task but we all work for one outcome. We are required to work together inorder to solve difficult tasks together and come up with a solution as a team. Like forexample, today in class different tasks were assigned to several students. This tasks were created to tackle as an individual or team of two or three depending on the task given but we work as a team by asking questions and coming up with good solutions for different executable tasks.</p>
</section>
<section id="fb2" class="level2">
<h2 class="anchored" data-anchor-id="fb2">FB2</h2>
<p><strong>Summary</strong></p>
<p>This FB2 chapter serves as a thorough guide to understanding the significance of code coverage in software testing. It elucidates how code coverage metrics can be employed to gauge the efficacy of tests and introduces a Coverage class for assessing coverage in Python applications. The guide further explores various coverage types, including statement, branch, and path coverage, and their application in enhancing testing procedures. It also discusses the strategic use of code coverage in directing fuzzing towards untested areas in a program.</p>
<p><strong>Reflection</strong></p>
<p>I find the concept of code coverage be valuable tool in software testing. It provides a quantitative measure that can help developers like me understand the effectiveness of my test cases.</p>
<p><strong>Use-case</strong></p>
<p>When we are working on a large Python application as a team, we have conducted numerous tests to ensure the functionality of the code. However, we may not be certain if these tests are comprehensive enough. This is where the concept of code coverage becomes valuable. By utilizing the Coverage class, we can quantify how much of the code is actually being tested. This includes verifying which statements, branches, and paths in the code are covered by our designed tests. If we discover that certain parts of the code are not covered, we can develop additional tests to cover those areas, thereby enhancing the overall quality of our software.</p>
</section>
</section>
<section id="week-4" class="level1">
<h1>Week 4</h1>
<section id="se3" class="level2">
<h2 class="anchored" data-anchor-id="se3">SE3</h2>
<p><strong>Summary</strong></p>
<p>The chapter from “Software Engineering at Google” on “How to Work Well on Teams” emphasizes the importance of adapting to the system, working well within teams, and sharing ideas and work. The chapter is divided into sections discussing the significance of conforming to the system for success, the necessity of teamwork and collaboration in software engineering, and the detrimental effects of withholding one’s work and ideas. It provides practical tips for improving communication, collaboration, and teamwork within software engineering teams. This chapter underscores that software engineering is not a solitary endeavor, but a team effort that requires open sharing of ideas and constructive criticism.</p>
<p><strong>Reflection</strong></p>
<p>This chapter underscored the significance of adaptability, collaboration, and openness in a software engineering environment. It conveyed that success isn’t solely about individual brilliance, but also hinges on one’s ability to effectively operate within a system and collaborate with a team. This resonates with our class experience, as we collectively work towards building a cohesive team, aiding each other in resolving issues and providing support when someone encounters difficulties. The chapter further emphasizes the necessity for effective communication and the courage to openly share ideas. It promotes the understanding that constructive criticism is a conduit for improvement rather than a personal affront</p>
<p><strong>Use-case</strong></p>
<p>In terms of a use-case, this guide mentioned in the chapter can serve as a valuable resource for our software engineering class, particularly when working on complex projects. It can help us foster a dynamic team. For instance, if there’s a system or process that you find challenging, instead of resisting it, you could strive to understand and adapt to it by working together as a team and coming up with solutions.</p>
</section>
<section id="fb3" class="level2">
<h2 class="anchored" data-anchor-id="fb3">FB3</h2>
<p><strong>Summary</strong></p>
<p>The chapter on <code>Fuzzing: Breaking Things with Random Inputs</code> provides an overview of fuzzing, as a process that involves feeding a program with random input to uncover failures. It emphasizes the importance of running fuzzers in a safe environment and acknowledges the potential risks involved. The chapter suggests using a program-runner to feed the generated input into an external program and provides an example using the “bc” calculator program. IN addition, it discusses prerequisites such as a basic understanding of Python and software testing fundamentals, and explains how to create and verify input files. It concludes by highlighting the benefits and risks of fuzzing, and offers practical steps for implementation using Python.</p>
<p><strong>Reflection</strong></p>
<p>Reflecting on this chapter, it’s clear that fuzzing is a powerful tool in software testing, allowing us to uncover potential failures by feeding a program with random input. However, it also highlights the importance of caution, as fuzzing can potentially harm the system if not done in a safe environment.</p>
<p><strong>Use-case</strong></p>
<p>When workin on our big project <code>chasten</code>, we could use fuzzing to test the robustness of the application against unexpected or random inputs. By generating a string of random characters using a fuzzer function and feeding it into our application, we could uncover potential failures or crashes. THi could be dont by giving it test cases and going through them. This would be particularly useful in testing the limits of our application. However, we would want to ensure this is done in a controlled environment to prevent any unintended damage to your system.</p>
</section>
</section>
<section id="week-5" class="level1">
<h1>Week 5</h1>
<section id="se4" class="level2">
<h2 class="anchored" data-anchor-id="se4">SE4</h2>
<p><strong>Summary</strong></p>
<p>The chapter on <code>knowledge sharing</code> explains the significance of fostering a learning culture within an organization, where individuals are encouraged to acknowledge their knowledge gaps, ask questions, and seek for help if needed. It advocates for knowledge-sharing as a scalable solution that benefits the entire organization, and can be achieved through various methods like group chats, mailing lists, and Q&amp;A systems. The chapter also highlights the role of mentorship in promoting learning, urging individuals to share their expertise and experiences. It emphasizes that learning is a continuous process, and no one person holds all the answers.</p>
<p><strong>Reflection</strong></p>
<p>The chapter resonates with the idea that no one has all the answers. It’s a reminder that it’s okay to not know everything and to ask for help when needed. It also emphasizes the importance of sharing knowledge and experiences, which can be rewarding not just for the individual, but for the entire team. This promotes a culture of continuous learning and growth, which is something I believe is essential in both professional and personal development.</p>
<p><strong>Use-case</strong></p>
<p>In our software development company, a culture of learning and knowledge sharing is crucial. For instance, when a developer encounters a complex bug, they could leverage the teams knowledge-sharing platforms such as discord or github issue trackers to seek help or find if someone else has already solved a similar issue. This not only promotes individual learning but also prevents duplication of effort. Additionally, more experienced team members could take on mentorship roles, guiding newer members and sharing their expertise, further fostering a collaborative and continuous learning environment.</p>
</section>
<section id="fb4" class="level2">
<h2 class="anchored" data-anchor-id="fb4">FB4</h2>
<p><strong>Summary</strong></p>
<p>The chapter emphasizes the significance of assessing a test suite’s effectiveness in identifying program bugs. It critiques the limitations of structural coverage measures and introduces mutation analysis as a more comprehensive method. This process involves introducing artificial faults into the program and evaluating if the test suite can detect them. It uses a “triangle” program as an example to demonstrate that high coverage doesn’t guarantee bug detection. It introduces the concept of a mutation score to assess the quality of assertions in a test suite. The chapter concludes by highlighting the importance of evaluating assertions’ effectiveness and suggests further evaluation beyond coverage measures.</p>
<p><strong>Reflection</strong></p>
<p>Reading this chapter has made me realize the importance of thorough testing in software development. It’s not just about achieving high coverage, but also about the quality of assertions and their ability to uncover bugs. The concept of mutation analysis was particularly enlightening. It’s a reminder that we need to constantly innovate and improve our testing strategies to ensure the reliability of our software.</p>
<p><strong>Use-case</strong></p>
<p>Consider a software development project for a banking application. The application has a feature to transfer funds between accounts. A test suite is developed with high structural coverage, ensuring all execution paths are tested. However, the test suite may still miss bugs if it doesn’t have strong assertions. By applying mutation analysis, we could introduce artificial faults, such as reversing the direction of fund transfer or changing the conditions for transfer limits. If the test suite fails to detect these mutations, it indicates that the assertions need to be strengthened. This way, mutation analysis can help improve the effectiveness of the test suite in catching bugs, leading to a more robust banking application.</p>
</section>
</section>
<section id="week-7" class="level1">
<h1>Week 7</h1>
<section id="se5" class="level2">
<h2 class="anchored" data-anchor-id="se5">SE5</h2>
<p><strong>Summary</strong></p>
<p>The chapter on <code>Engineering for Equity</code> underscores the significance of equality, justice, and diversity in the tech industry, particularly in firms like Google. It promotes a comprehensive strategy to tackle systemic disparities, with an emphasis on psychological safety, enhancing multicultural competence, ongoing professional growth, and diverse representation. The chapter also points out the responsibility of tech companies in mitigating bias within their teams and products, and the potential negative consequences of biased actions. Contrasting with the previous chapter which focused on the importance of knowledge sharing within a team, this chapter sheds light on understanding our backgrounds and stresses the importance of maintaining equality in the workplace.</p>
<p><strong>Reflection</strong></p>
<p>I find this chapter to be incredibly insightful. It not only highlights the systemic issues prevalent in the tech industry but also provides actionable steps to address them. The emphasis on psychological safety and multicultural competence resonates with me as these are crucial for fostering an inclusive work environment. The call for continuous professional development is a reminder that learning is a lifelong process and is essential for personal growth and career advancement.</p>
<p><strong>Use-case</strong></p>
<p>In our software development class, the chapter on <code>Engineering for Equity</code> might not seem directly applicable at first glance. However, it provides valuable insights that will be crucial when we transition into professional roles in tech companies like Google. The chapter encourages us to proactively address issues of inequality and incorporate solutions into company policies. When instances of inequality arise, it’s important to communicate them to our supervisors. Organizing workshops or training sessions could be an effective way to address these issues and promote a more equitable work environment.</p>
</section>
<section id="fb5" class="level2">
<h2 class="anchored" data-anchor-id="fb5">FB5</h2>
<p><strong>Summary</strong></p>
<p>The chapter introduces <code>Mutation-based fuzzing</code>, a software testing method that generates random inputs and alters them to find program vulnerabilities. It explains how this method can guide test generation using coverage information. The text also introduces the American Fuzzy Lop (AFL), a popular tool that evolves test cases by finding new execution paths. Furthermore, it discusses the basics of mutational fuzz testing and how it can be directed towards specific code goals.</p>
<p><strong>Reflection</strong></p>
<p>The chapter on <code>Mutation-based fuzzing</code> provides a comprehensive overview of mutation-based fuzzing, highlighting its importance in identifying vulnerabilities in software programs. It emphasizes the role of tools like AFL in evolving test cases and finding new execution paths, showcasing the dynamic nature of this testing method. The ability to direct testing towards specific code goals further underscores the versatility and strategic application of mutational fuzz testing.</p>
<p><strong>Use-case</strong></p>
<p>In our software development company, when working on including new tools in our <code>chasten</code> program, we use mutation-based fuzzing for the testing process to ensure that the implemented tools are robust before launch. This method generates random inputs and uses AFL to mutate these inputs, uncovering potential vulnerabilities that were not identified during regular testing. By directing the fuzz testing towards specific code goals, we can focus on areas of the code that are particularly critical or complex. This helps us enhance the reliability of the tools before they are released to users.</p>
</section>
</section>
<section id="week-8" class="level1">
<h1>Week 8</h1>
<section id="se6" class="level2">
<h2 class="anchored" data-anchor-id="se6">Se6</h2>
<p><strong>Summary</strong></p>
<p>The chapter on <code>How to Lead a Team</code> is a comprehensive guide that emphasizes the importance of leadership in a team, particularly in software engineering. It discusses the significance of humility, respect, and trust within a team and how to build a strong collective team. The chapter highlights the various leadership roles recognized at Google, such as the visionary, the coach, and the consensus builder. It also delves into the qualities of a good leader, emphasizing humility and respect, and clarifies that losing one’s ego does not equate to lacking confidence. The chapter provides insights on leading a team effectively, emphasizing understanding individual needs, being a good listener, setting clear expectations, and providing constructive feedback.</p>
<p><strong>Reflection</strong></p>
<p>Reflecting on this, it’s clear that effective leadership requires a balance of various skills and qualities. A good leader is not just someone who directs but someone who listens, understands, and respects their team members. They recognize the individual needs of their team members and foster an environment that allows each member to excel.</p>
<p><strong>Use-case</strong></p>
<p>For a use-case, in our software engineering team when working on the <code>chaten</code> tool, as a collaborative effort, any one of us could take the initiative to be productive and assume the role of a leader to guide our small group teams. The team leader can apply the principles from this chapter to ensure effective leadership. As leaders, we can strive to understand our team’s needs, provide clear expectations for the project, and offer constructive feedback throughout the development process. By fostering an environment of respect and trust, we can cultivate a strong collective team identity that can contribute to the successful completion of the <code>chaten</code> project.</p>
</section>
<section id="fb6" class="level2">
<h2 class="anchored" data-anchor-id="fb6">FB6</h2>
<p><strong>Summary</strong></p>
<p><strong>Reflection</strong></p>
<p><strong>Use-case</strong></p>
</section>
</section>
<section id="week-9" class="level1">
<h1>Week 9</h1>
<section id="se7" class="level2">
<h2 class="anchored" data-anchor-id="se7">Se7</h2>
<p><strong>Summary</strong></p>
<p>The chapter on <code>Leading at Scale</code> is a comprehensive guide for engineering leaders aiming to lead multiple teams. It emphasizes transitioning from individual contributors to team leaders, prioritizing tasks, listening to diverse opinions, and building a strong team culture. The chapter suggests that focusing on the top 20% of critical tasks and encourages leaders to create an environment where team members feel valued, supported, and empowered.</p>
<p><strong>Reflection</strong></p>
<p>This guide resonates with me as it underscores the importance of effective leadership in achieving team success. It reminds me that leadership is not just about directing but also about listening, prioritizing, and creating a conducive environment for the team. The emphasis on focusing on the top 20% of tasks is particularly enlightening as it’s easy to get caught up in less important tasks.</p>
<p><strong>Use-case</strong></p>
<p>This chapter can be incredibly beneficial for new engineering managers transitioning from individual contributors to team leaders. They can utilize these strategies to manage their teams effectively, prioritize tasks, and foster a robust team culture. For instance, a project manager in a software development company, or even in our software engineering class, can use this guide to enhance their leadership skills. This, in turn, can boost the productivity of our chosen tools and uplift the morale of our team.</p>
</section>
<section id="fb7" class="level2">
<h2 class="anchored" data-anchor-id="fb7">FB7</h2>
<p><strong>Summary</strong></p>
<p>The chapter on <code>Efficient Grammar Fuzzing</code> provides a comprehensive guide to using grammars for effective software testing. It emphasizes the efficiency of grammar-based fuzzing in finding bugs that other methods might miss and offers practical examples and best practices. The chapter also recommends a coverage-guided approach and mutation-based techniques to optimize the fuzzing process.</p>
<p><strong>Reflection</strong></p>
<p>This chapter underscores the importance of grammar-based fuzzing in software testing. It highlights how this method, by generating complex inputs, can uncover bugs that might otherwise remain hidden. The emphasis on a coverage-guided approach and mutation-based techniques provides valuable insights into optimizing the fuzzing process.</p>
<p><strong>Use-case</strong></p>
<p>As a software engineering class, when working on complex projects like <code>chasten</code>, we can utilize the strategies outlined in this chapter to enhance our testing process. For instance, we can employ grammars to generate a diverse range of inputs for our software, thereby increasing the likelihood of uncovering hidden bugs.</p>
<p>Here’s a simple Python script that demonstrates how one might use a grammar to generate random strings for testing:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Define a simple grammar</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>grammar <span class="op">=</span> {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"&lt;start&gt;"</span>: [<span class="st">"&lt;string&gt;"</span>],</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"&lt;string&gt;"</span>: [<span class="st">"&lt;letter&gt;"</span>, <span class="st">"&lt;letter&gt;&lt;string&gt;"</span>],</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"&lt;letter&gt;"</span>: [<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>, <span class="st">"d"</span>, <span class="st">"e"</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate(grammar, symbol):</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> symbol <span class="kw">not</span> <span class="kw">in</span> grammar:</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> symbol</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        production <span class="op">=</span> random.choice(grammar[symbol])</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">""</span>.join(generate(grammar, sym) <span class="cf">for</span> sym <span class="kw">in</span> production.split())</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate a random string using the grammar</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>random_string <span class="op">=</span> generate(grammar, <span class="st">"&lt;start&gt;"</span>)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(random_string)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This script above employs a simple grammar to generate random strings composed of the letters ‘a’ through ‘e’. This could be integrated into a fuzzing process to test how a piece of software handles various inputs.</p>
</section>
</section>
<section id="week-10" class="level1">
<h1>Week 10</h1>
<section id="se8" class="level2">
<h2 class="anchored" data-anchor-id="se8">Se8</h2>
<p><strong>Summary</strong></p>
<p><strong>Reflection</strong></p>
<p><strong>Use-case</strong></p>
</section>
<section id="fb8" class="level2">
<h2 class="anchored" data-anchor-id="fb8">FB8</h2>
<p><strong>Summary</strong></p>
<p><strong>Reflection</strong></p>
<p><strong>Use-case</strong></p>
</section>
</section>
<section id="week-11" class="level1">
<h1>Week 11</h1>
<section id="se9" class="level2">
<h2 class="anchored" data-anchor-id="se9">Se9</h2>
<p><strong>Summary</strong></p>
<p>The chapter on <code>Code review</code> mentions as a process where a code is examined by someone other than the author before it’s added to the codebase. It checks for code correctness, comprehensibility, and consistency. At Google, code reviews are extensive and involve multiple reviewers. The goal is to get approval from another engineer, indicated by “looks good to me” (LGTM). Code reviews help uncover defects early, save time on testing and debugging, promote collaboration, prevent technical debt, and improve code quality. Despite variations in the software industry, code review is seen as a crucial step for code quality and efficient collaboration.</p>
<p><strong>Reflection</strong></p>
<p>The chapter highlights the importance of code reviews in maintaining high-quality code and fostering collaboration among engineers. It underscores that code reviews are not just about finding bugs, but also about ensuring that the code is understandable, consistent, and maintainable. The practice of code review, as described at Google, emphasizes the importance of collective ownership and knowledge sharing in software development. It’s interesting to note that code reviews are seen as a crucial, albeit imperfect, process that contributes to the scalability and success of a software organization over time.</p>
<p><strong>Use-case</strong></p>
<p>Consider our software engineering class that is struggling with code quality and collaboration issues among its students. Implementing a rigorous code review process, similar to the one described at Google, could be beneficial. This process would involve multiple reviewers who check the code for correctness, comprehensibility, and consistency. The primary goal would be to gain approval from another student, fostering a sense of team ownership. This practice could help uncover defects early, save time on testing and debugging, promote collaboration, prevent technical debt, and ultimately improve the overall quality of the code. This would help us avoid introducing bugs that could break the system. Over time, this could contribute to the scalability and success of our projects.</p>
</section>
<section id="fb9" class="level2">
<h2 class="anchored" data-anchor-id="fb9">FB9</h2>
<p><strong>Summary</strong></p>
<p>Delta debugging is a systematic technique used to identify the smallest possible input that still triggers a failure or error. It works by progressively removing parts of the input and testing if the error persists. The aim is to minimize the input while still reproducing the failure, simplifying the analysis and resolution of the underlying issue. The process begins by dividing the input into chunks and testing them individually. If a chunk doesn’t cause a failure, it’s discarded, and the process continues with the remaining chunks. This iterative approach gradually reduces the input size while checking the impact on the error. A caching mechanism can be used to store the results of previously tested inputs, avoiding redundant tests and saving time and computational resources. This technique is particularly useful in debugging and fixing software issues. By isolating and minimizing the problematic input, developers can focus on analyzing and resolving the specific cause of the failure, making the debugging process more manageable and targeted.</p>
<p><strong>Reflection</strong></p>
<p>Reflecting on this, delta debugging is a powerful tool for software developers. It automates the process of isolating the cause of a software failure, saving time and effort. It also makes the debugging process more efficient by focusing on the minimal inputs that trigger failures.</p>
<p><strong>Use-case</strong></p>
<p>Consider a software development company working on a complex application. During testing, they encounter a failure when running a specific set of inputs. Instead of manually trying to isolate the cause, they could use delta debugging to automatically identify the minimal input that triggers the failure. This would allow them to quickly identify and fix the issue, improving the quality of their software and reducing the time spent on debugging.</p>
</section>
</section>
<section id="week-13" class="level1">
<h1>Week 13</h1>
<section id="se10" class="level2">
<h2 class="anchored" data-anchor-id="se10">Se10</h2>
<p><strong>Summary</strong></p>
<p>The chapter <code>Style Guides and Rules</code> in the “Software Engineering at Google” book discusses the importance of rules and guidelines in coding practices within engineering organizations. It highlights Google’s approach, emphasizing tailored style guides for various programming languages and the adaptive nature of rules. The chapter illustrates how rules adapt with a case study and emphasizes the importance of standardization, local reasoning, readability, and consistency in maintaining an efficient codebase.</p>
<p><strong>Reflection</strong></p>
<p>The chapter provides valuable insights into the dynamic nature of rules and guidance in software engineering. It underscores the importance of adaptability and evolution in response to changing industry standards and language traits. The emphasis on local reasoning, readability, and consistency resonates with the need for clear understanding of code without extensive cross-referencing. The balance between enforcing rules and providing guides as best practices reflects a pragmatic approach to coding practices.</p>
<p><strong>Use-case</strong></p>
<p>A practical example from the chapter is Google’s shift in Python naming conventions from CamelCase to snake_case. This change demonstrates the need for adaptability in maintaining effective guidelines for software engineering. Another example is the allowance of std::unique_ptr in C++11 after aligning with style guidance. These instances show how rules can adapt over time to accommodate evolving languages and functionalities. Automation through formatting linters and tests aids in maintaining consistency and adhering to guidelines, further illustrating the application of these principles in a real-world setting.</p>
</section>
<section id="db1" class="level2">
<h2 class="anchored" data-anchor-id="db1">DB1</h2>
<p><strong>Summary</strong></p>
<p>The chapter on <code>Introduction to Debugging</code> discusses the process of debugging using a Python program that removes HTML tags as an example. It introduces a systematic debugging strategy based on the scientific method, emphasizing understanding the code, fixing the problem instead of symptoms, and proceeding systematically. The chapter provides a specific example of testing a hypothesis about the removal of double quotes from tagged input using the assert statement. It concludes by highlighting the challenges of debugging, including the complexity of program states and the lack of specifications.</p>
<p><strong>Reflection</strong></p>
<p>The chapter provides valuable insights into effective debugging strategies. It emphasizes the importance of thorough documentation and clear thinking during the debugging process. The use of the scientific method in debugging, involving formulating hypotheses, making predictions, testing hypotheses through experiments, and refining hypotheses based on observations, is particularly interesting. The chapter also underscores the importance of post-fix activities to ensure the long-term health and correctness of a software application.</p>
<p><strong>Use-case</strong></p>
<p>A practical example from the chapter is the debugging of a Python program that removes HTML tags. The initial code segment had a hypothesis that was tested using an assert statement. The hypothesis was about the removal of double quotes from tagged input. The incorrect condition failed to handle single and double quotes correctly. The corrected condition ensured that the code inside the block was executed only when either a single or double quote was encountered and the tag variable was true. After fixing the code, post-fix activities were suggested, including checking for further occurrences of the defect, validating tests, adding assertions for future correctness checks, committing the fix to the code repository, and closing the bug report. This example illustrates the application of the principles discussed in the chapter in a real-world setting.</p>
</section>
</section>
<section id="week-14" class="level1">
<h1>Week 14</h1>
<section id="se11" class="level2">
<h2 class="anchored" data-anchor-id="se11">Se11</h2>
<p><strong>Summary</strong></p>
<p>The chapter on <code>Testing Overview</code> discusses the importance and value of software testing at Google. It outlines how implementing a comprehensive test suite drastically reduced the number of bugs in production code. Testing provides many benefits like less debugging, increased confidence in changes, improved documentation, simpler code reviews, thoughtful design, and faster, higher-quality releases. The text describes different testing scope levels - small unit tests, medium integration tests, and large end-to-end tests. It recommends having mostly narrow unit tests, some integration tests, and just a few end-to-end tests. The “Beyoncé Rule” states that valuable new features should have test coverage to validate functionality and reduce the chance of removal later. Testing has limitations though and determining test value is a human task. Overall, testing fosters team inclusiveness through knowledge sharing and helps companies survive long-term.</p>
<p><strong>Reflection</strong></p>
<p>The chapter provides very compelling support for the value of comprehensive testing in software engineering. Seeing the specific example from Google about how test enforcement cut production bugs in half reinforced my belief that testing should be an integral part of the development process, not an afterthought. The categorization of testing into unit, integration and end-to-end makes sense conceptually. In practice, it can be challenging to achieve an ideal balance between different test types depending on system complexity. But aiming for mostly narrow unit tests as the foundation does seem like a thoughtful guideline. I appreciated the “Beyoncé Rule” as a catchy motto that reminds developers the importance of validating their contributions through tests for posterity. The limitations around determining test quality and usefulness also resonated with my experience that some areas inevitably depend more on human evaluation. Overall, I found this a worthwhile, convincing overview of why thorough testing matters and deserves ongoing investment despite obstacles.</p>
<p><strong>Use-case</strong></p>
<p>In our software development class, as we work on our projects <code>chasten</code> and <code>cellveyor</code>, we can apply the key lessons from this chapter to devise an effective testing approach. Following Google’s model, we will structure our test coverage into unit, integration, and end-to-end levels. Narrow unit tests will validate individual class methods, functions, algorithms, and modules in isolation to prevent basic defects. Medium integration tests will ensure that components cooperate properly by testing interface functionality between frontend, backend, and database tiers. Broader system tests will put the fully integrated product through representative workflows but will require substantial mocking. We encourage our team to adopt an iterative testing process. This involves writing test cases, running them, and reacting to the results. This process should be repeated until the code is well-written and effective, as demonstrated by tests passing in GitHub Actions.</p>
</section>
<section id="db2" class="level2">
<h2 class="anchored" data-anchor-id="db2">DB2</h2>
<p><strong>Summary</strong></p>
<p>The chapter on <code>Tracing Executions</code>in The Debugging Book introduces the concept of Tracer, a tool that monitors and shows how a function behaves, including its inputs and outputs. Tracer uses the sys.settrace() command to trace everything in a program, providing access to the current line number, variables, and more. The chapter also discusses the use of the frame argument, which holds the function and its local variables. A function traceit is defined to trace the input program and print out the event, providing a line-by-line account of what happens in the program. The chapter further explores the application of the tracing function in a class and introduces the concept of ConditionalTracer, which logs specific conditional expressions during executions.</p>
<p><strong>Reflection</strong></p>
<p>The chapter provides valuable insights into the use of Tracer for debugging. It emphasizes the importance of tracing in understanding the behavior of a program and identifying issues. The use of sys.settrace() and the traceit function demonstrates a powerful approach to tracking events in code. The discussion on applying the tracing function in a class and using ConditionalTracer provides a comprehensive view of the tools available for debugging.</p>
<p><strong>Use-case</strong></p>
<p>Our software development team, working on the <code>chasten</code> and <code>cellveyor</code> projects, has refined our debugging process after reading an article. We have emphasized the cause-and-effect chain in our code, enhanced our test case development, and integrated the scientific method into our debugging process. We have updated our documentation practices and committed to continuous learning through training programs that cover the latest debugging techniques, tools, and best practices. By implementing these actions, our team can empower with a robust methodology for debugging, leading to more effective diagnosis and resolution of bugs, and ultimately a more stable and reliable software product. This use case illustrates the real-world application of the insights from the chapter to enhance our team’s ability to debug code effectively.</p>
</section>
</section>
<section id="week-15" class="level1">
<h1>Week 15</h1>
<section id="se12" class="level2">
<h2 class="anchored" data-anchor-id="se12">Se12</h2>
<p><strong>Summary</strong></p>
<p><strong>Reflection</strong></p>
<p><strong>Use-case</strong></p>
</section>
<section id="db3" class="level2">
<h2 class="anchored" data-anchor-id="db3">DB3</h2>
<p><strong>Summary</strong></p>
<p><strong>Reflection</strong></p>
<p><strong>Use-case</strong></p>
</section>
</section>
<section id="week-16" class="level1">
<h1>Week 16</h1>
<section id="db4" class="level2">
<h2 class="anchored" data-anchor-id="db4">DB4</h2>
<p><strong>Summary</strong></p>
<p><strong>Reflection</strong></p>
<p><strong>Use-case</strong></p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>